---
description: TypeScript best practices and conventions
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---
# TypeScript Guidelines

## Type Safety

### Use Explicit Types
```typescript
// ✅ Good: Explicit return type
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ❌ Bad: Implicit any
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

### Avoid `any` Type
```typescript
// ✅ Good: Use specific types or unknown
function processData(data: unknown): ProcessedData {
  if (isValidData(data)) {
    return transform(data);
  }
  throw new Error('Invalid data');
}

// ❌ Bad: Using any
function processData(data: any): ProcessedData {
  return transform(data);
}
```

## Type Definitions

### Prefer Interfaces for Object Shapes
```typescript
// ✅ Good: Interface for object shape
interface User {
  id: string;
  name: string;
  email: string;
}

// ✅ Good: Type for unions, intersections, primitives
type Status = 'pending' | 'approved' | 'rejected';
type UserWithStatus = User & { status: Status };
```

### Use Type Aliases for Complex Types
```typescript
// ✅ Good: Type alias for complex types
type EventHandler<T> = (event: T) => void;
type AsyncResult<T> = Promise<{ data: T; error?: Error }>;
```

## Function Signatures

### Use Function Declarations for Hoisting
```typescript
// ✅ Good: Function declaration
function processOrder(order: Order): void {
  // Implementation
}

// ✅ Good: Arrow function for callbacks
const handleClick = (event: MouseEvent): void => {
  // Implementation
};
```

## Generics

### Use Descriptive Generic Names
```typescript
// ✅ Good: Descriptive generic names
function mapArray<TItem, TResult>(
  items: TItem[],
  mapper: (item: TItem) => TResult
): TResult[] {
  return items.map(mapper);
}

// ❌ Bad: Single letter generics without context
function mapArray<T, U>(items: T[], mapper: (item: T) => U): U[] {
  return items.map(mapper);
}
```

## Enums vs Union Types

### Prefer Union Types for Simple Cases
```typescript
// ✅ Good: Union type for simple cases
type Theme = 'light' | 'dark';

// ✅ Good: Enum for complex cases with methods
enum Status {
  Pending = 'pending',
  Approved = 'approved',
  Rejected = 'rejected',
  
  isFinal() {
    return this === Status.Approved || this === Status.Rejected;
  }
}
```

## Null Safety

### Use Optional Chaining and Nullish Coalescing
```typescript
// ✅ Good: Safe property access
const userName = user?.profile?.name ?? 'Anonymous';

// ❌ Bad: Unsafe property access
const userName = user.profile.name || 'Anonymous';
```

## Import/Export

### Use Named Exports
```typescript
// ✅ Good: Named exports
export function calculateTotal(items: Item[]): number {
  // Implementation
}

export const DEFAULT_CONFIG = { /* ... */ };

// ❌ Bad: Default exports (use sparingly)
export default function calculateTotal(items: Item[]) {
  // Implementation
}
```

## Type Guards

### Create Type Guards for Runtime Checks
```typescript
// ✅ Good: Type guard function
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    'email' in obj
  );
}

// Usage
if (isUser(data)) {
  // TypeScript knows data is User here
  console.log(data.name);
}
```
