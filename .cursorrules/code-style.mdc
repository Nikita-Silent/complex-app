---
description: General coding standards and style guide
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: false
---
# Code Style Guide

## Naming Conventions

### Variables and Functions
```typescript
// ✅ Good: camelCase for variables and functions
const userName = 'John';
const isActive = true;
function calculateTotal() { }

// ❌ Bad: snake_case or PascalCase
const user_name = 'John';
const IsActive = true;
function CalculateTotal() { }
```

### Constants
```typescript
// ✅ Good: UPPER_SNAKE_CASE for constants
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';

// ✅ Good: camelCase for const objects/arrays
const defaultConfig = { timeout: 5000 };
const allowedRoles = ['admin', 'user'];
```

### Classes and Types
```typescript
// ✅ Good: PascalCase for classes and types
class UserService { }
interface UserProfile { }
type ApiResponse<T> = { data: T };

// ❌ Bad: camelCase for classes
class userService { }
```

### Components
```typescript
// ✅ Good: PascalCase for React components
function UserProfile() { }
const Button = () => { };

// ✅ Good: camelCase for component files
// UserProfile.tsx
```

## Formatting

### Indentation
- Use 2 spaces for indentation
- Use consistent spacing around operators and keywords

```typescript
// ✅ Good: Consistent spacing
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => {
    return sum + item.price;
  }, 0);
}

// ❌ Bad: Inconsistent spacing
function calculateTotal(items:Item[]):number{
  return items.reduce((sum,item)=>{
    return sum+item.price;
  },0);
}
```

### Line Length
- Maximum 100 characters per line
- Break long lines at logical points

```typescript
// ✅ Good: Broken at logical point
const result = await fetchUserData(
  userId,
  { includeProfile: true, includeSettings: true }
);

// ❌ Bad: Too long line
const result = await fetchUserData(userId, { includeProfile: true, includeSettings: true });
```

## Comments

### Use Comments Sparingly
```typescript
// ✅ Good: Self-documenting code
function calculateDiscount(price: number, discountPercent: number): number {
  return price * (1 - discountPercent / 100);
}

// ❌ Bad: Unnecessary comments
// This function calculates discount
function calculateDiscount(price: number, discountPercent: number): number {
  // Multiply price by discount percentage
  return price * (1 - discountPercent / 100);
}
```

### Document Complex Logic
```typescript
// ✅ Good: Explain why, not what
// Using binary search for O(log n) performance on large datasets
function findUser(users: User[], id: string): User | null {
  // Implementation
}
```

## Code Organization

### Import Order
1. External dependencies
2. Internal modules
3. Types
4. Relative imports

```typescript
// ✅ Good: Organized imports
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/Button';
import { UserService } from '@/services/UserService';
import type { User } from '@/types/User';
import './styles.css';
```

### Function Length
- Keep functions focused and under 50 lines
- Extract complex logic into separate functions

```typescript
// ✅ Good: Short, focused function
function validateEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// ❌ Bad: Long function doing multiple things
function processUser(user: User): void {
  // 100+ lines of mixed concerns
}
```

## Error Handling

### Use Meaningful Error Messages
```typescript
// ✅ Good: Descriptive error
if (!user) {
  throw new Error(`User with ID ${userId} not found`);
}

// ❌ Bad: Generic error
if (!user) {
  throw new Error('Error');
}
```

### Handle Errors Appropriately
```typescript
// ✅ Good: Proper error handling
try {
  const result = await fetchData();
  return result;
} catch (error) {
  if (error instanceof NetworkError) {
    // Handle network error
  } else {
    // Handle other errors
    throw error;
  }
}
```

## Best Practices

1. **DRY (Don't Repeat Yourself)** - Extract common logic into reusable functions
2. **KISS (Keep It Simple, Stupid)** - Prefer simple solutions over complex ones
3. **YAGNI (You Aren't Gonna Need It)** - Don't add functionality until needed
4. **Single Responsibility** - Each function/class should do one thing well
5. **Early Returns** - Use early returns to reduce nesting
