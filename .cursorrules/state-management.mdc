---
description: State management approaches and best practices
globs: ["**/store/**", "**/state/**", "**/hooks/use*.ts", "**/context/**"]
alwaysApply: false
---
# State Management Guidelines

## State Management Strategy

### Local State (useState)
Use for component-specific state that doesn't need to be shared.

```typescript
// ✅ Good: Local state for component-specific data
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

### Context API
Use for state that needs to be shared across multiple components but not globally.

```typescript
// ✅ Good: Context for shared state
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  
  const login = async (email: string, password: string) => {
    const userData = await authService.login(email, password);
    setUser(userData);
  };
  
  const logout = () => {
    setUser(null);
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

## State Management Libraries

### Redux (if using)
```typescript
// ✅ Good: Typed Redux setup
interface RootState {
  user: UserState;
  products: ProductsState;
}

// ✅ Good: Typed hooks
const dispatch = useAppDispatch();
const user = useAppSelector(state => state.user);
```

### Zustand (if using)
```typescript
// ✅ Good: Simple store with TypeScript
interface BearState {
  bears: number;
  increase: () => void;
  decrease: () => void;
}

const useBearStore = create<BearState>((set) => ({
  bears: 0,
  increase: () => set((state) => ({ bears: state.bears + 1 })),
  decrease: () => set((state) => ({ bears: state.bears - 1 })),
}));
```

## Custom Hooks for State

### Encapsulate State Logic
```typescript
// ✅ Good: Custom hook for complex state logic
function useForm<T>(initialValues: T) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  
  const setValue = useCallback((key: keyof T, value: T[keyof T]) => {
    setValues(prev => ({ ...prev, [key]: value }));
    // Clear error when value changes
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[key];
      return newErrors;
    });
  }, []);
  
  const validate = useCallback(() => {
    // Validation logic
  }, [values]);
  
  return { values, errors, setValue, validate };
}
```

## State Updates

### Immutable Updates
```typescript
// ✅ Good: Immutable state updates
setState(prev => ({
  ...prev,
  count: prev.count + 1,
}));

// ✅ Good: Updating nested objects
setUser(prev => ({
  ...prev,
  profile: {
    ...prev.profile,
    name: newName,
  },
}));

// ❌ Bad: Mutating state directly
state.count = state.count + 1;
```

### Batch Updates
```typescript
// ✅ Good: React batches state updates automatically
function handleClick() {
  setCount(count + 1);
  setName('New Name');
  // Both updates are batched
}

// ✅ Good: Use functional updates for dependent updates
function handleClick() {
  setCount(prev => prev + 1);
  setTotal(prev => prev + 1);
}
```

## Derived State

### Use useMemo for Expensive Calculations
```typescript
// ✅ Good: Memoize derived state
const filteredItems = useMemo(() => {
  return items.filter(item => 
    item.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [items, searchTerm]);
```

### Avoid Redundant State
```typescript
// ❌ Bad: Storing derived state
const [items, setItems] = useState<Item[]>([]);
const [filteredItems, setFilteredItems] = useState<Item[]>([]);

// ✅ Good: Compute derived state
const [items, setItems] = useState<Item[]>([]);
const filteredItems = useMemo(() => 
  items.filter(item => item.isActive),
  [items]
);
```

## Best Practices

1. **Start with local state** - Use useState unless you need to share state
2. **Lift state up** - Move shared state to common ancestor
3. **Use Context sparingly** - Only for truly shared state
4. **Keep state normalized** - Avoid nested structures when possible
5. **Use TypeScript** - Type your state and actions
6. **Avoid prop drilling** - Use Context or state management library
7. **Memoize expensive computations** - Use useMemo for derived state
8. **Keep state minimal** - Don't store what you can compute
